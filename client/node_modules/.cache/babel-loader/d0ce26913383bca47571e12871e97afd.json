{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n/* eslint-disable no-plusplus */\n\nvar INFINITY = 10000;\n\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        var j = i === 0 ? i + 1 : i;\n\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n\n        position = j - 1;\n      }\n\n      break;\n    }\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n\nvar _default = applyBestFit;\nexports.default = _default;","map":{"version":3,"sources":["D:/GitHub/PxU/client/node_modules/@react-pdf/textkit/lib/engines/linebreaker/bestFit.js"],"names":["exports","__esModule","default","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","position","minimumBadness","Infinity","sum","width","stretch","shrink","lineLength","Math","min","length","calculateRatio","node","i","type","j","ratio","penalty","badness","pow","abs","applyBestFit","nodes","count","breakpoints","breakpoint","push","slice","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/* eslint-disable no-plusplus */\nvar INFINITY = 10000;\n\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        var j = i === 0 ? i + 1 : i;\n\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n\n        position = j - 1;\n      }\n\n      break;\n    }\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n\nvar _default = applyBestFit;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}